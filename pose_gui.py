import cv2
import mediapipe as mp
import numpy as np
import os
import time
import tkinter as tk
from tkinter import messagebox, ttk
import random
from playsound import playsound

# --- Global/Shared Variables for Trackbar and GUI interaction ---
current_tolerance_int = 5 # Default tolerance (maps to 0.05)

# Variables to be set by the GUI
REFERENCE_FILE_PATH = None
REQUIRED_HOLD_TIME = None # This will now be set randomly per pose
pose_files = [] # Global list to store available pose data files
current_pose_index = 0 # Global index to track the current pose file
MAX_POSES_TO_CYCLE = 0 # 0 for unlimited, will be set by GUI
SHOW_TIME_ELAPSED = True # Default to showing time elapsed

# --- Scoring Parameters ---
total_challenge_score = 0.0
MAX_ADOPTION_TIME_SECONDS = 10.0 # Max seconds to adopt a pose to get points
ADOPTION_POINTS_MAX = 100.0 # Max points for adoption speed
HOLDING_POINTS_MAX = 100.0 # Max points for holding quality

# Per-pose scoring variables (reset when new pose starts)
current_pose_adoption_score = 0.0
current_pose_holding_score = 0.0
current_pose_start_challenge_time = None # Time when the *current* pose challenge began
is_current_pose_adoption_scored = False # Flag to ensure adoption score is calculated only once

# --- Helper Function for Angle Calculation ---
def calculate_angle(a, b, c):
    """
    Calculates the angle (in degrees) between three 3D points.
    Points a, b, and c are MediaPipe landmarks (x, y, z).
    b is the vertex of the angle.
    """
    a = np.array([a.x, a.y]) # Convert to numpy array for vector operations
    b = np.array([b.x, b.y])
    c = np.array([c.x, c.y])

    # Calculate vectors
    ba = a - b
    bc = c - b

    # Calculate cosine of the angle using dot product formula
    cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
    # Ensure cosine_angle is within [-1, 1] to avoid arccos domain errors
    cosine_angle = max(-1.0, min(1.0, cosine_angle))
    
    # Calculate angle in radians and convert to degrees
    angle = np.degrees(np.arccos(cosine_angle))
    return angle

# --- Helper Function to Read Parameters from File ---
def read_parameters_from_file(filepath):
    """
    Reads pose parameters from a text file generated by the previous script.
    Returns a dictionary of parameter labels and their float/tuple values.
    """
    params = {}
    try:
        with open(filepath, 'r') as f:
            lines = f.readlines()
            for line in lines:
                line = line.strip()
                if line and "---" not in line: # Skip header/footer lines
                    try:
                        label, value_str = line.split(': ', 1)
                        # Try to parse as float, if not, keep as string (for tuples)
                        try:
                            value = float(value_str)
                        except ValueError:
                            # Handle tuple strings like "(0.50, 0.75)"
                            if value_str.startswith('(') and value_str.endswith(')'):
                                parts = value_str[1:-1].split(', ')
                                value = tuple(float(p) for p in parts)
                            else:
                                value = value_str # Fallback for any other string data
                        params[label] = value
                    except ValueError:
                        print(f"Warning: Could not parse line in file: {line}")
                        continue
    except FileNotFoundError:
        print(f"Error: Reference file not found at {filepath}")
        return None
    except Exception as e:
        print(f"Error reading parameters from file: {e}")
        return None
    return params

# --- Function to Compare Poses ---
def compare_poses(reference_params, current_params, tolerance=0.1):
    """
    Comparisons current pose parameters against reference parameters.
    Returns True if the poses match within the given tolerance, False otherwise.
    Tolerance applies to normalized coordinates (0.0 to 1.0) and angles (degrees).
    """
    if not reference_params or not current_params:
        return False

    match = True
    # reasons = [] # Uncomment for debugging mismatch reasons

    landmark_map = {
        "Left Elbow Angle": ("Left Elbow Angle", lambda: current_params.get("Left Elbow Angle")),
        "Right Elbow Angle": ("Right Elbow Angle", lambda: current_params.get("Right Elbow Angle")),
        "Left Wrist (x,y)": ("Left Wrist (x,y)", lambda: current_params.get("Left Wrist (x,y)")),
        "Right Wrist (x,y)": ("Right Wrist (x,y)", lambda: current_params.get("Right Wrist (x,y)")),
        "Left Shoulder (x,y)": ("Left Shoulder (x,y)", lambda: current_params.get("Left Shoulder (x,y)")),
        "Right Shoulder (x,y)": ("Right Shoulder (x,y)", lambda: current_params.get("Right Shoulder (x,y)")),
        "Left Knee Angle": ("Left Knee Angle", lambda: current_params.get("Left Knee Angle")),
        "Right Knee Angle": ("Right Knee Angle", lambda: current_params.get("Right Knee Angle")),
        "Left Hip Angle": ("Left Hip Angle", lambda: current_params.get("Left Hip Angle")),
        "Right Hip Angle": ("Right Hip Angle", lambda: current_params.get("Right Hip Angle")),
        "Left Hip.y - Left Knee.y": ("Left Hip.y - Left Knee.y", lambda: current_params.get("Left Hip.y - Left Knee.y")),
    }

    for label, current_getter in landmark_map.items():
        ref_value = reference_params.get(label)
        cur_value = current_getter[1]()

        if ref_value is None or cur_value is None:
            match = False
            # reasons.append(f"Missing data for {label}")
            continue

        if isinstance(ref_value, float):
            adjusted_tolerance = tolerance * (180.0 if "Angle" in label else 1.0)
            if abs(ref_value - cur_value) > adjusted_tolerance:
                match = False
                # reasons.append(f"{label} mismatch: Ref={ref_value:.2f}, Cur={cur_value:.2f} (Diff={abs(ref_value - cur_value):.2f}, Tol={adjusted_tolerance:.2f})")
        elif isinstance(ref_value, tuple) and len(ref_value) == 2:
            if abs(ref_value[0] - cur_value[0]) > tolerance or \
               abs(ref_value[1] - cur_value[1]) > tolerance:
                match = False
                # reasons.append(f"{label} mismatch: Ref={ref_value}, Cur={cur_value} (Diff_x={abs(ref_value[0] - cur_value[0]):.2f}, Diff_y={abs(ref_value[1] - cur_value[1]):.2f}, Tol={tolerance:.2f})")

    return match, []

# --- Trackbar Callback Function ---
def on_trackbar_change(val):
    global current_tolerance_int
    current_tolerance_int = val

# --- GUI Setup Function ---
def setup_pose_challenge_gui():
    global REFERENCE_FILE_PATH, pose_files, current_pose_index, MAX_POSES_TO_CYCLE, SHOW_TIME_ELAPSED

    root = tk.Tk()
    root.title("Pose Challenge Setup")
    root.geometry("450x420") # Increased height for new option
    root.resizable(False, False)

    tk.Label(root, text="Configure your Pose Challenge:", font=('Arial', 14, 'bold')).pack(pady=10)

    tk.Label(root, text="1. Select Reference Pose File:", font=('Arial', 10)).pack(pady=5)
    
    pose_files.extend([f for f in os.listdir('.') if f.endswith('_pose_data.txt')]) # Populate global list
    if not pose_files:
        messagebox.showerror("Error", "No pose data files (*_pose_data.txt) found in the current directory.\n\nPlease use the 'pose_detection_code' to generate reference pose data first.")
        root.destroy()
        return False

    selected_file_var = tk.StringVar(root)
    selected_file_var.set(pose_files[0]) # default value
    
    file_dropdown = ttk.Combobox(root, textvariable=selected_file_var, values=pose_files, state="readonly", width=40)
    file_dropdown.pack(pady=2)

    # --- Hold Time Display (now randomized) ---
    tk.Label(root, text=f"2. Hold Pose For: Randomized (15-60 seconds)", font=('Arial', 10)).pack(pady=5)


    # --- Max Poses to Cycle Input ---
    tk.Label(root, text="3. Max Poses to Cycle (0 for unlimited):", font=('Arial', 10)).pack(pady=5)
    max_poses_entry = tk.Entry(root, width=10, justify='center', font=('Arial', 12))
    max_poses_entry.insert(0, "0") # Default to unlimited
    max_poses_entry.pack(pady=2)

    # --- Show Time Elapsed Checkbox ---
    show_time_var = tk.BooleanVar(value=True) # Default to True (checked)
    tk.Checkbutton(root, text="Show Time Elapsed on Display", variable=show_time_var, 
                   font=('Arial', 10)).pack(pady=10)


    def on_start_button_click():
        global REFERENCE_FILE_PATH, MAX_POSES_TO_CYCLE, SHOW_TIME_ELAPSED
        REFERENCE_FILE_PATH = selected_file_var.get()
        current_pose_index = pose_files.index(REFERENCE_FILE_PATH) # Set initial index based on selection
        
        try:
            max_poses_value = int(max_poses_entry.get())
            if max_poses_value < 0:
                raise ValueError("Max poses must be a non-negative integer.")
            MAX_POSES_TO_CYCLE = max_poses_value
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter a valid non-negative integer for max poses (e.g., 5 or 0 for unlimited).")
            return
        
        SHOW_TIME_ELAPSED = show_time_var.get() # Get the checkbox value

        try:
            # Construct the path to the sound file
            sound_file_path = os.path.join('sounds', 'start', 'start_01.wav')
            playsound(sound_file_path) # Play sound when start button is clicked
        except Exception as e:
            print(f"Could not play sound '{sound_file_path}': {e}")
            messagebox.showwarning("Sound Warning", f"Could not play sound '{sound_file_path}'. Make sure the file exists at the specified path and the playsound library is correctly installed.")

        root.destroy()

    start_button = tk.Button(root, text="Start Pose Challenge", command=on_start_button_click, 
                             font=('Arial', 12, 'bold'), bg='green', fg='white', relief='raised', padx=10, pady=5)
    start_button.pack(pady=20)

    root.mainloop()

    # Return True if values were successfully set, False otherwise (e.g., if GUI was closed)
    return REFERENCE_FILE_PATH is not None and MAX_POSES_TO_CYCLE is not None


# --- Main Execution Flow ---
if not setup_pose_challenge_gui():
    print("Pose challenge setup cancelled or failed.")
    exit()

# Now REFERENCE_FILE_PATH and MAX_POSES_TO_CYCLE are set by the GUI.
# REQUIRED_HOLD_TIME will be set for the first pose below.
print(f"Challenge set to cycle through a maximum of {MAX_POSES_TO_CYCLE} poses." if MAX_POSES_TO_CYCLE > 0 else "Challenge set to cycle through poses indefinitely.")
print(f"Time elapsed display: {'Enabled' if SHOW_TIME_ELAPSED else 'Disabled'}")


mp_pose = mp.solutions.pose
mp_drawing = mp.solutions.drawing_utils

pose = mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5)

# --- Webcam Initialization ---
cap = cv2.VideoCapture(0)
if not cap.isOpened():
    print("Error: Could not open webcam.")
    messagebox.showerror("Webcam Error", "Could not open webcam. Please ensure it's connected and not in use.")
    exit()
print("Webcam opened successfully. Press 'q' to quit.")

# Create the display window and trackbar
window_name = 'Pose Comparison'
cv2.namedWindow(window_name, cv2.WINDOW_NORMAL) # Make window resizable
cv2.resizeWindow(window_name, 960, 720) # Set initial window size (width, height)
cv2.createTrackbar('Tolerance (x 0.01)', window_name, current_tolerance_int, 100, on_trackbar_change)

# --- Timer variables for pose holding ---
pose_start_time = None # When continuous hold began for the current pose
pose_held_duration = 0.0
poses_completed_count = 0 # New variable to track completed poses

# --- Initialize the first pose and its random hold time and scoring ---
reference_parameters = read_parameters_from_file(REFERENCE_FILE_PATH)
if reference_parameters is None:
    print("Failed to load reference parameters from selected file. Exiting.")
    exit()
REQUIRED_HOLD_TIME = random.uniform(15.0, 60.0) # Set initial random hold time
current_pose_start_challenge_time = time.time() # Start timing for adoption of the first pose
is_current_pose_adoption_scored = False
current_pose_adoption_score = 0.0
current_pose_holding_score = 0.0

print(f"Initial pose loaded: {os.path.basename(REFERENCE_FILE_PATH).replace('_pose_data.txt', '')} (Hold for {REQUIRED_HOLD_TIME:.1f}s)")


# --- Main Loop for Pose Detection and Comparison ---
while True:
    ret, frame = cap.read()
    if not ret:
        print("Error: Could not read frame. Exiting...")
        break

    frame = cv2.flip(frame, 1) # Flip for webcam mirroring
    image_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    image_rgb.flags.writeable = False

    results = pose.process(image_rgb)

    image_rgb.flags.writeable = True
    image_bgr = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2BGR)

    current_target_pose_name = os.path.basename(REFERENCE_FILE_PATH).replace('_pose_data.txt', '')
    
    # Update status text to include challenge progress
    if MAX_POSES_TO_CYCLE > 0:
        comparison_status_text = f"Target: {current_target_pose_name} ({poses_completed_count}/{MAX_POSES_TO_CYCLE})"
    else:
        comparison_status_text = f"Target: {current_target_pose_name} (Unlimited)"

    status_color = (0, 0, 255) # Red for default/no match

    current_params = {}

    if results.pose_landmarks:
        mp_drawing.draw_landmarks(
            image_bgr,
            results.pose_landmarks,
            mp_pose.POSE_CONNECTIONS,
            landmark_drawing_spec=mp_drawing.DrawingSpec(color=(245, 117, 66), thickness=2, circle_radius=2),
            connection_drawing_spec=mp_drawing.DrawingSpec(color=(245, 66, 230), thickness=2, circle_radius=2)
        )

        landmarks = results.pose_landmarks.landmark

        left_shoulder = landmarks[mp_pose.PoseLandmark.LEFT_SHOULDER.value]
        left_elbow = landmarks[mp_pose.PoseLandmark.LEFT_ELBOW.value]
        left_wrist = landmarks[mp_pose.PoseLandmark.LEFT_WRIST.value]
        right_shoulder = landmarks[mp_pose.PoseLandmark.RIGHT_SHOULDER.value]
        right_elbow = landmarks[mp_pose.PoseLandmark.RIGHT_ELBOW.value]
        right_wrist = landmarks[mp_pose.PoseLandmark.RIGHT_WRIST.value]
        left_hip = landmarks[mp_pose.PoseLandmark.LEFT_HIP.value]
        right_hip = landmarks[mp_pose.PoseLandmark.RIGHT_HIP.value]
        left_knee = landmarks[mp_pose.PoseLandmark.LEFT_KNEE.value]
        right_knee = landmarks[mp_pose.PoseLandmark.RIGHT_KNEE.value]
        left_ankle = landmarks[mp_pose.PoseLandmark.LEFT_ANKLE.value]
        right_ankle = landmarks[mp_pose.PoseLandmark.RIGHT_ANKLE.value]

        current_params["Left Elbow Angle"] = calculate_angle(left_shoulder, left_elbow, left_wrist)
        current_params["Right Elbow Angle"] = calculate_angle(right_shoulder, right_elbow, right_wrist)
        current_params["Left Wrist (x,y)"] = (left_wrist.x, left_wrist.y)
        current_params["Right Wrist (x,y)"] = (right_wrist.x, right_wrist.y)
        current_params["Left Shoulder (x,y)"] = (left_shoulder.x, left_shoulder.y)
        current_params["Right Shoulder (x,y)"] = (right_shoulder.x, right_shoulder.y)
        current_params["Left Knee Angle"] = calculate_angle(left_hip, left_knee, left_ankle)
        current_params["Right Knee Angle"] = calculate_angle(right_hip, right_knee, right_ankle)
        current_params["Left Hip Angle"] = calculate_angle(left_shoulder, left_hip, left_knee)
        current_params["Right Hip Angle"] = calculate_angle(right_shoulder, right_hip, right_knee)
        current_params["Left Hip.y - Left Knee.y"] = left_hip.y - left_knee.y

        tolerance_value = current_tolerance_int / 100.0 # Convert trackbar int to float tolerance
        is_same_pose, mismatch_reasons = compare_poses(reference_parameters, current_params, tolerance=tolerance_value)
        
        if is_same_pose:
            if pose_start_time is None:
                pose_start_time = time.time()
            pose_held_duration = time.time() - pose_start_time

            # Calculate adoption score *only once* when pose is first adopted
            if not is_current_pose_adoption_scored:
                adoption_time = time.time() - current_pose_start_challenge_time
                if adoption_time <= MAX_ADOPTION_TIME_SECONDS:
                    current_pose_adoption_score = ADOPTION_POINTS_MAX * (1 - (adoption_time / MAX_ADOPTION_TIME_SECONDS))
                    # Play praise sound if adoption was successful (score > 0)
                    try:
                        praise_sound_path = os.path.join('sounds', 'praise', 'praise_01.wav')
                        playsound(praise_sound_path)
                    except Exception as e:
                        print(f"Could not play praise sound '{praise_sound_path}': {e}")
                else:
                    current_pose_adoption_score = 0.0 # No adoption score if too slow
                is_current_pose_adoption_scored = True # Mark as scored

            if pose_held_duration >= REQUIRED_HOLD_TIME:
                # Pose successfully held for duration
                current_pose_holding_score = HOLDING_POINTS_MAX # Full holding points
                
                # Add to total score only ONCE when pose is completed
                # This check ensures we don't add the score repeatedly in the same frame
                if poses_completed_count < (MAX_POSES_TO_CYCLE if MAX_POSES_TO_CYCLE > 0 else float('inf')): # Ensure not already completed
                    total_challenge_score += (current_pose_adoption_score + current_pose_holding_score)

                if SHOW_TIME_ELAPSED:
                    comparison_status_text += f" - POSE HELD! ({pose_held_duration:.1f}s)"
                else:
                    comparison_status_text += f" - POSE HELD!"
                status_color = (0, 255, 0) # Green for success
                poses_completed_count += 1

                if MAX_POSES_TO_CYCLE > 0 and poses_completed_count >= MAX_POSES_TO_CYCLE:
                    messagebox.showinfo("Challenge Complete!", f"Congratulations! You held {MAX_POSES_TO_CYCLE} poses for various durations!\nTotal Score: {total_challenge_score:.0f}")
                    break # End challenge
                else:
                    # Move to the next pose
                    current_pose_index = (current_pose_index + 1) % len(pose_files)
                    REFERENCE_FILE_PATH = pose_files[current_pose_index]
                    reference_parameters = read_parameters_from_file(REFERENCE_FILE_PATH)
                    if reference_parameters is None:
                        print(f"Error: Could not load next reference file: {REFERENCE_FILE_PATH}. Exiting.")
                        break
                    
                    # Randomize hold time for the NEW pose
                    REQUIRED_HOLD_TIME = random.uniform(15.0, 60.0) 
                    print(f"\nMoving to next pose: {os.path.basename(REFERENCE_FILE_PATH).replace('_pose_data.txt', '')} (Hold for {REQUIRED_HOLD_TIME:.1f}s)")
                    
                    # Reset per-pose timers and scoring flags for the new pose
                    pose_start_time = None
                    pose_held_duration = 0.0
                    current_pose_start_challenge_time = time.time() # Reset challenge start time for the new pose
                    is_current_pose_adoption_scored = False
                    current_pose_adoption_score = 0.0 # Reset display score for current pose
                    current_pose_holding_score = 0.0 # Reset display score for current pose

            else: # Pose matching, but not held long enough
                if SHOW_TIME_ELAPSED:
                    comparison_status_text += f" - Hold: {pose_held_duration:.1f}/{REQUIRED_HOLD_TIME:.1f}s"
                else:
                    comparison_status_text += f" - Hold Pose!"
                status_color = (0, 255, 255) # Yellow while holding
        else: # Pose NOT matching
            pose_start_time = None # Reset continuous hold timer
            pose_held_duration = 0.0
            # If pose broken before first match, reset adoption score for next attempt at this pose
            if not is_current_pose_adoption_scored:
                 current_pose_adoption_score = 0.0 # Reset to 0 if not adopted yet
            current_pose_holding_score = 0.0 # Holding score is 0 if not matching
            comparison_status_text += " - Mismatch"
            status_color = (0, 0, 255)

    cv2.putText(image_bgr, comparison_status_text, (50, 50), 
                cv2.FONT_HERSHEY_SIMPLEX, 1, status_color, 2, cv2.LINE_AA)

    # Display overall score at a fixed position
    cv2.putText(image_bgr, f"Total Score: {total_challenge_score:.0f}", (10, 90), # Top left, below main status
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2, cv2.LINE_AA)

    # Display current pose's estimated score (before completion)
    current_estimated_pose_score = current_pose_adoption_score + current_pose_holding_score # Will be inaccurate before completion, but shows progress
    cv2.putText(image_bgr, f"Current Pose Score: {current_estimated_pose_score:.0f}", (10, 120), # Top left, below total score
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 0), 2, cv2.LINE_AA) # Yellow for current pose score


    cv2.imshow(window_name, image_bgr) # Use the named window

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()

print("Application closed.")